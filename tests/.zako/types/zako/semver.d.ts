/// <reference path="./global.d.ts" />
// Generated by dts-bundle-generator v9.5.1

export declare namespace inc {
	/** Base number to be used for the prerelease identifier */
	type IdentifierBase = "0" | "1" | false;
}
/**
 * Return the version incremented by the release type (major, premajor, minor, preminor, patch, prepatch, or prerelease), or null if it's not valid.
 */
export declare function inc(version: string | SemVer, release: ReleaseType, optionsOrLoose?: boolean | Options, identifier?: string, identifierBase?: inc.IdentifierBase): string | null;
export declare function inc(version: string | SemVer, release: ReleaseType, identifier: string, identifierBase?: inc.IdentifierBase): string | null;
export declare class SemVer {
	constructor(version: string | SemVer, optionsOrLoose?: boolean | RangeOptions);
	raw: string;
	loose: boolean;
	options: Options;
	format(): string;
	inspect(): string;
	major: number;
	minor: number;
	patch: number;
	version: string;
	build: readonly string[];
	prerelease: ReadonlyArray<string | number>;
	/**
	 * Compares two versions excluding build identifiers (the bit after `+` in the semantic version string).
	 *
	 * @return
	 * - `0` if `this` == `other`
	 * - `1` if `this` is greater
	 * - `-1` if `other` is greater.
	 */
	compare(other: string | SemVer): 1 | 0 | -1;
	/**
	 * Compares the release portion of two versions.
	 *
	 * @return
	 * - `0` if `this` == `other`
	 * - `1` if `this` is greater
	 * - `-1` if `other` is greater.
	 */
	compareMain(other: string | SemVer): 1 | 0 | -1;
	/**
	 * Compares the prerelease portion of two versions.
	 *
	 * @return
	 * - `0` if `this` == `other`
	 * - `1` if `this` is greater
	 * - `-1` if `other` is greater.
	 */
	comparePre(other: string | SemVer): 1 | 0 | -1;
	/**
	 * Compares the build identifier of two versions.
	 *
	 * @return
	 * - `0` if `this` == `other`
	 * - `1` if `this` is greater
	 * - `-1` if `other` is greater.
	 */
	compareBuild(other: string | SemVer): 1 | 0 | -1;
	inc(release: ReleaseType, identifier?: string, identifierBase?: inc.IdentifierBase): SemVer;
	toString(): string;
}
/**
 * Return the parsed version as a `SemVer` object.
 *
 * In case `version` is invalid, the function will
 * - throw if `throwErrors` is `true`.
 * - return `null` otherwise.
 */
export declare function parse(version?: string | SemVer | null): SemVer | null;
export declare function parse(version: string | SemVer | null | undefined, optionsOrLoose: boolean | Options, throwErrors: true): SemVer;
export declare function parse(version: string | SemVer | null | undefined, optionsOrLoose: boolean | Options, throwErrors?: boolean): SemVer | null;
/**
 * Return the parsed version as a string, or null if it's not valid.
 */
export declare function valid(version: string | SemVer | null | undefined, optionsOrLoose?: boolean | Options): string | null;
/**
 * Returns cleaned (removed leading/trailing whitespace, remove '=v' prefix) and parsed version, or null if version is invalid.
 */
export declare function clean(version: string, optionsOrLoose?: boolean | Options): string | null;
/**
 * Returns difference between two versions by the release type (major, premajor, minor, preminor, patch, prepatch, or prerelease), or null if the versions are the same.
 */
export declare function diff(v1: string | SemVer, v2: string | SemVer): ReleaseType | null;
/**
 * Return the major version number.
 */
export declare function major(version: string | SemVer, optionsOrLoose?: boolean | Options): number;
/**
 * Return the minor version number.
 */
export declare function minor(version: string | SemVer, optionsOrLoose?: boolean | Options): number;
/**
 * Return the patch version number.
 */
export declare function patch(version: string | SemVer, optionsOrLoose?: boolean | Options): number;
/**
 * Returns an array of prerelease components, or null if none exist.
 */
export declare function prerelease(version: string | SemVer, optionsOrLoose?: boolean | Options): ReadonlyArray<string | number> | null;
/**
 * Compares two versions excluding build identifiers (the bit after `+` in the semantic version string).
 *
 * Sorts in ascending order when passed to `Array.sort()`.
 *
 * @return
 * - `0` if `v1` == `v2`
 * - `1` if `v1` is greater
 * - `-1` if `v2` is greater.
 */
export declare function compare(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): 1 | 0 | -1;
/**
 * The reverse of compare.
 *
 * Sorts in descending order when passed to `Array.sort()`.
 */
export declare function rcompare(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): 1 | 0 | -1;
/**
 * Short for compare(v1, v2, { loose: true })
 */
export declare function compareLoose(v1: string | SemVer, v2: string | SemVer): 1 | 0 | -1;
/**
 * Compares two versions including build identifiers (the bit after `+` in the semantic version string).
 *
 * Sorts in ascending order when passed to `Array.sort()`.
 *
 * @return
 * - `0` if `v1` == `v2`
 * - `1` if `v1` is greater
 * - `-1` if `v2` is greater.
 *
 * @since 6.1.0
 */
export declare function compareBuild(a: string | SemVer, b: string | SemVer, optionsOrLoose?: boolean | Options): 1 | 0 | -1;
/**
 * Sorts an array of semver entries in ascending order using `compareBuild()`.
 */
export declare function sort<T extends string | SemVer>(list: T[], optionsOrLoose?: boolean | Options): T[];
/**
 * Sorts an array of semver entries in descending order using `compareBuild()`.
 */
export declare function rsort<T extends string | SemVer>(list: T[], optionsOrLoose?: boolean | Options): T[];
/**
 * v1 > v2
 */
export declare function gt(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * v1 < v2
 */
export declare function lt(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * v1 == v2 This is true if they're logically equivalent, even if they're not the exact same string. You already know how to compare strings.
 */
export declare function eq(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * v1 != v2 The opposite of eq.
 */
export declare function neq(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * v1 >= v2
 */
export declare function gte(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * v1 <= v2
 */
export declare function lte(v1: string | SemVer, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * Pass in a comparison string, and it'll call the corresponding semver comparison function.
 * "===" and "!==" do simple string comparison, but are included for completeness.
 * Throws if an invalid comparison string is provided.
 */
export declare function cmp(v1: string | SemVer, operator: Operator, v2: string | SemVer, optionsOrLoose?: boolean | Options): boolean;
/**
 * Coerces a string to SemVer if possible
 */
export declare function coerce(version: string | number | SemVer | null | undefined, options?: CoerceOptions): SemVer | null;
export declare class Comparator {
	constructor(comp: string | Comparator, optionsOrLoose?: boolean | Options);
	semver: SemVer;
	operator: "" | "=" | "<" | ">" | "<=" | ">=";
	value: string;
	loose: boolean;
	options: Options;
	parse(comp: string): void;
	test(version: string | SemVer): boolean;
	intersects(comp: Comparator, optionsOrLoose?: boolean | Options): boolean;
}
export declare class Range {
	constructor(range: string | Range, optionsOrLoose?: boolean | RangeOptions);
	range: string;
	raw: string;
	loose: boolean;
	options: Options;
	includePrerelease: boolean;
	format(): string;
	inspect(): string;
	set: ReadonlyArray<readonly Comparator[]>;
	parseRange(range: string): readonly Comparator[];
	test(version: string | SemVer): boolean;
	intersects(range: Range, optionsOrLoose?: boolean | Options): boolean;
}
/**
 * Return true if the version satisfies the range.
 */
export declare function satisfies(version: string | SemVer, range: string | Range, optionsOrLoose?: boolean | RangeOptions): boolean;
/**
 * Return the highest version in the list that satisfies the range, or null if none of them do.
 */
export declare function maxSatisfying<T extends string | SemVer>(versions: readonly T[], range: string | Range, optionsOrLoose?: boolean | RangeOptions): T | null;
/**
 * Return the lowest version in the list that satisfies the range, or null if none of them do.
 */
export declare function minSatisfying<T extends string | SemVer>(versions: readonly T[], range: string | Range, optionsOrLoose?: boolean | RangeOptions): T | null;
/**
 * Mostly just for testing and legacy API reasons
 */
export declare function toComparators(range: string | Range, optionsOrLoose?: boolean | Options): string[][];
/**
 * Return the lowest version that can possibly match the given range.
 */
export declare function minVersion(range: string | Range, optionsOrLoose?: boolean | Options): SemVer | null;
/**
 * Return the valid range or null if it's not valid
 */
export declare function validRange(range: string | Range | null | undefined, optionsOrLoose?: boolean | RangeOptions): string | null;
/**
 * Return true if the version is outside the bounds of the range in either the high or low direction.
 * The hilo argument must be either the string '>' or '<'. (This is the function called by gtr and ltr.)
 */
export declare function outside(version: string | SemVer, range: string | Range, hilo: ">" | "<", optionsOrLoose?: boolean | RangeOptions): boolean;
/**
 * Return true if version is greater than all the versions possible in the range.
 */
export declare function gtr(version: string | SemVer, range: string | Range, optionsOrLoose?: boolean | RangeOptions): boolean;
/**
 * Return true if version is less than all the versions possible in the range.
 */
export declare function ltr(version: string | SemVer, range: string | Range, optionsOrLoose?: boolean | RangeOptions): boolean;
/**
 * Return true if any of the ranges comparators intersect
 */
export declare function intersects(range1: string | Range, range2: string | Range, optionsOrLoose?: boolean | RangeOptions): boolean;
/**
 * Return a "simplified" range that matches the same items in `versions` list as the range specified.
 * Note that it does *not* guarantee that it would match the same versions in all cases,
 * only for the set of versions provided.
 * This is useful when generating ranges by joining together multiple versions with `||` programmatically,
 * to provide the user with something a bit more ergonomic.
 * If the provided range is shorter in string-length than the generated range, then that is returned.
 */
declare function simplify(ranges: string[], range: string | Range, options?: Options): string | Range;
/**
 * Return true if the subRange range is entirely contained by the superRange range.
 */
export declare function subset(sub: string | Range, dom: string | Range, options?: RangeOptions): boolean;
/**
 * Compares two identifiers, must be numeric strings or truthy/falsy values.
 *
 * Sorts in ascending order when passed to `Array.sort()`.
 */
export function compareIdentifiers(a: string | null | undefined, b: string | null | undefined): 1 | 0 | -1;
/**
 * The reverse of compareIdentifiers.
 *
 * Sorts in descending order when passed to `Array.sort()`.
 */
export function rcompareIdentifiers(a: string | null | undefined, b: string | null | undefined): 1 | 0 | -1;
export const SEMVER_SPEC_VERSION: "2.0.0";
export const RELEASE_TYPES: ReleaseType[];
export type ReleaseType = "major" | "premajor" | "minor" | "preminor" | "patch" | "prepatch" | "prerelease" | "release";
export interface Options {
	loose?: boolean | undefined;
}
export interface RangeOptions extends Options {
	includePrerelease?: boolean | undefined;
}
export interface CoerceOptions extends Options {
	/**
	 * If the `options.includePrerelease` flag is set, then the `coerce` result will contain
	 * prerelease and build parts of a version. For example, `1.2.3.4-rc.1+rev.2`
	 * will preserve prerelease `rc.1` and build `rev.2` in the result.
	 *
	 * @default false
	 * @since 7.6.0
	 */
	includePrerelease?: boolean | undefined;
	/**
	 * If the `options.rtl` flag is set, then `coerce` will return the right-most
	 * coercible tuple that does not share an ending index with a longer coercible
	 * tuple.  For example, `1.2.3.4` will return `2.3.4` in rtl mode, not
	 * `4.0.0`.  `1.2.3/4` will return `4.0.0`, because the `4` is not a part of
	 * any other overlapping SemVer tuple.
	 *
	 * @default false
	 * @since 6.2.0
	 */
	rtl?: boolean | undefined;
}
export type Operator = "===" | "!==" | "" | "=" | "==" | "!=" | ">" | ">=" | "<" | "<=";

export {
	simplify as simplifyRange,
};

export {};
